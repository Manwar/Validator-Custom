=encoding utf8

=head1 NAME

Validator::Custom::Guides::Ja - Validator::Customの日本語ガイド

=head1 ガイド

=head2 1. 基本

B<1. 新しいL<Validator::Custom>オブジェクトの生成>

    use Validator::Custom;
    my $vc = Validator::Custom->new;

B<2. バリデーションのためのデータの準備>

    my $data = {age => 19, name => 'Ken Suzuki'};


データはハッシュリファレンスでなければなりません。

B<3. バリデーションのためのルールの準備>

    my $rule = [
        age => {message => 'age must be integer'} => [
            'not_blank',
            'int'
        ],
        name => {message => 'name must be string. the length 1 to 5'} => [
            'not_blank',
            {length => [1, 5]}
        ],
        price => [
            'not_blank',
            'int'
        ]
    ];

データが完全に正しいものであるかどうかを調べるには、
C<is_ok()>を使用します。
C<is_ok()>は「不正なパラメータの値が存在しない」かつ
「ルールで指定されたすべてのパラメータ名がデータの中に存在する」
ときに真の値を返します。

ルールの中で指定されたパラメータ名のうち少なくともひとつが
データの中にない場合は、C<has_missing()>は真の値を返します。

発見できなかったパラメータ名を取得するには、C<missing_params()>
を使用します。このサンプルの場合は戻り値は以下になります。

    ['price']

パラメータの値のうち少なくともひとつが不正なものであった場合は、
C<has_invalid()>は真の値を返します。この例では
戻り値は以下になります。

    {
        name => 'name must be string. the length 1 to 5'
    }

L<Validator::Custom::Result>の詳細は
L</"2. バリデーションの結果">で解説されています。

=head2 2. バリデーションの結果

C<validate()>はL<Validator::Custom::Result>オブジェクトを返します。
さまざまなメソッドを使って結果を扱うことができます。

C<is_ok()>, C<has_missing()>, C<has_invalid()>, C<missing_params()>,
C<messages_to_hash()>はすでにL</"1. 基本">で解説しました。

次のものはよく使うメソッドです。

B<data()>

    my $data = $result->data;

最終状態のデータを取得します。L<Validator::Custom>はフィルタリングの
機能を持っています。C<validate()>に渡されたデータのパラメータの値は
フィルターによって他のデータに変換されているかもしれません。
C<data()>によってフィルタ後のデータを取得することができます。

B<messages()>

    my $messages = $result->messages;

パラメータの値が不正であったパラメータ名に対応するメッセージ(すべて)を
取得します。メッセージはルールで指定されたパラメータ名の順序を保持して
います。

B<message()>

    my $message = $result->message('name');

パラメータの値が不正であったパラメータ名に対応するメッセージ(ひとつ)を
取得します。

L<Validator::Custom::Result>のすべてのAPIは
L<Validator::Custom::Result>のPODの中で解説されています。

=head2 3. ルールの文法

=head3 C<基本>

ルールは特定の構造を持ちます。

「ルール」は配列のリファレンスでなければなりません。

    my $rule = [
    
    ];

これは不正なパラメータ名の順序を維持するためです。

ルールはパラメータ名と(ひとつあるいは複数の)制約関数のペアを持ちます。

    my $rule = [
        age =>  [              # paramter name1        
            'not_blank',       #   constraint function1
            'int'              #   constraint function2
        ],                                                   
                                                             
        name => [              # parameter name2       
            'not_blank',       #   constraint function1
            {length => [1, 5]} #   constraint function2
        ]
    ];

制約関数は、ハッシュを使うと、引数を受け取ることができます。

    my $rule = [
        name => [
            {'length' => [1, 5]}
        ]
    ];

それぞれの制約関数ごとにメッセージを設定するができます。

    my $rule = [
        name => [
            ['not_blank', 'name must be not blank'],
            [{'length' => [1, 5]}, 'name must be 1 to 5 length']
        ]
    ];

=head3 C<オプション>

ルールにはオプションを設定することができます。

    my $rule = [
        price => {default => 1000, message => 'price must be integer'} => [
            'int'
        ]
    ];

You can set options for each paramter name.

    my $rule = [
               # Option #
        age => {message => 'age must be integer'} => [
            'not_blank',
        ]
    ];

Option is located after the paramter name,
and option must be hash reference.

The following options is available.

=over 4

=item 1. message

     {message => "This is invalid"}

パラメータの値が不正なパラメータ名に対応するメッセージを指定します。

=item 2. default

    {default => 5}

デフォルト値。パラメータの値が不正な場合、あるいは
ルールで指定されたパラメータ名がデータの中に見つからない場合
に、自動的にデータに設定されます。

=item 3. copy

    {copy => 0}

この値が0の場合は結果のデータにパラメータの値がコピーされません。

デフォルトは1で、パラメータの値はコピーされます。

=back

=head3 C<マルチパラメータバリデーション>

複数のパラメータのバリデーションを行うことができます。

    my $data = {password1 => 'xxx', password2 => 'xxx'};
    my $rule = [
        {password_check => [qw/password1 password2/]} => [
            'duplication'
        ]
    ];

このサンプルでは、'password1' と 'password2' が同じことを
確認しています。
制約関数C<duplication>には

    ['xxx', 'xxx']
    
という値が渡されます。

C<password_check>のような新しいキーを指定しなければなりません。
これはL<Validator::Result>オブジェクトによって利用されます。

必要であれば正規表現のリファレンスを使うことも可能です。

    my $data = {person1 => 'Taro', person2 => 'Rika', person3 => 'Ken'};
    my $rule = [
        {merged_person => qr/^person;/} => [
            'merge', # TaroRikaKen
        ]
    ];

マッチしたパラメータ名のすべての値が配列のリファレンスとして
制約関数にわたされます。この例では以下の値が渡されます。

    ['Taro', 'Rika', 'Ken']

=head3 C<否定のバリデーション> 

制約名の前に「!」を付けることによって、
制約関数の否定を行うことができます。

    $rule = [
        age => [
            '!int';
        ],
    ];

この意味は「age」は「int」ではないという意味です。
これはマルチバリューバリデーションと組み合わせることができます。

    $rule = [
        ages => [
            '@!int';
        ]
    ];

=head3 C<OR条件によるバリデーション>

OR条件によるバリデーションが利用できます。
C<||>を使ってください。

    $rule = [
        email => [
            'blank || email'
        ]
    ];



=head3 C<マルチバリューバリデーション>

パラメータの値がハッシュのリファレンスであった場合に、
マルチバリューバリデーションが利用できます。
「@」マークを制約関数名の前に追加してください。

    $data = {
        nums => [1, 2, 3]
    };
    
    $rule = [
        'nums' => [
            '@int'
        ]
    ];

=head2 4. 制約関数の仕様

制約関数の仕様を解説します。

    # Register constraint
    $vc->register_constraint(
        consrtaint_name => sub {
            my ($value, $args, $vc) = @_;
            
            # Do something
            
            return $is_valid;
        }
    )

=head3 C<引数と戻り値>

制約関数は3つの引数を受け取ります。

=over 4

=item 1.

値

=item 2.

(ルールの)引数

=item 3.

L<Validator::Custom>オブジェクト

=back

=over 4

=item 1. 値

これはデータの値です。

    my $data = {name => 'Ken Suzuki'};

この例では、値は「Ken Suzuki」です。

=item 2. ルールの引数

ルールの中で制約関数に引数を渡すことができます。

    my $rule = [
        name => [
            {length => [1, 5]}
        ]
    ];

この例では、引数は「[1, 5]」になります。

=back

また制約関数は値が正しいかどうかを
チェックするための値を返却する必要があります。

マルチパラメータバリデーションにおいては、
値は配列のリファレンスにパックされます。
値は「['xxx', 'xxx']」のようになります。

    $data = {password1 => 'xxx', password2 => 'xxx'};

    $rule = [
        {password_check => [qw/password1 password2/]} => [
            ['duplication', 'Two password must be equal']
        ]
    ];

=head3 C<フィルタ関数>

制約関数は、変換した値を返却することもできます。
もし変換された値を返却したい場合は、
配列のリファレンスを返す必要があります。
一番目の要素は「値が正しいかどうかを確認するための値」、
二番目の引数は、「変換された値」です。

    $vc->register_constraint(
        trim => sub {
            my $value = shift;
            
            $value =~ s/^\s+//;
            $value =~ s/\s+$//;
            
            return [1, $value];
        }
    );

=head2 5. 拡張

L<Validator::Custom>を拡張するのは簡単です。
制約関数を登録するには、継承したクラスの
コンストラクタの中でregister_constraintメソッドを
使用します。
    
    package YourValidator;
    use base 'Validator::Custom';
    
    sub new {
        my $self = shift->SUPER::new(@_);
        $self->register_constraint(
            defined  => sub { defined $_[0] }
        );
        return $self;
    }
    
    1;
    
L<Validator::Custom::HTMLForm>はよいサンプルです。

=cut
